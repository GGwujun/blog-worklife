<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-worklife/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-worklife";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>18｜http库：如何批量下载在线内容，解放鼠标（上）？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-worklife/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-worklife/大规模数据处理实战">大规模数据处理实战</a></li></ul></span><span>工作生活<ul><li><a href="/blog-worklife/10x程序员工作法">10x程序员工作法</a></li><li><a aria-current="page" class="active" href="/blog-worklife/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-worklife/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-worklife/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-worklife/基于人因的用户体验设计课">基于人因的用户体验设计课</a></li><li><a href="/blog-worklife/打造爆款短视频">打造爆款短视频</a></li><li><a href="/blog-worklife/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-worklife/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-worklife/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-worklife/讲好故事">讲好故事</a></li><li><a href="/blog-worklife/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-worklife/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-worklife/大规模数据处理实战">大规模数据处理实战</a></li></ul></li><li>工作生活<ul><li><a href="/blog-worklife/10x程序员工作法">10x程序员工作法</a></li><li><a aria-current="page" class="active" href="/blog-worklife/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-worklife/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-worklife/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-worklife/基于人因的用户体验设计课">基于人因的用户体验设计课</a></li><li><a href="/blog-worklife/打造爆款短视频">打造爆款短视频</a></li><li><a href="/blog-worklife/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-worklife/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-worklife/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-worklife/讲好故事">讲好故事</a></li><li><a href="/blog-worklife/跟着高手学复盘">跟着高手学复盘</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-worklife/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-worklife/python自动化办公实战课/01.课前必读">01.课前必读</a><ul><li><a href="/blog-worklife/python自动化办公实战课/01.课前必读/01"><span>开篇词 | 重复工作这么多，怎样才能提高工作效率？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/01.课前必读/02"><span>导读｜入门Python的必备知识</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/02.“输入”模块不同文件类型的批量合并和拆分问题">02.“输入”模块不同文件类型的批量合并和拆分问题</a><ul><li><a href="/blog-worklife/python自动化办公实战课/02.“输入”模块不同文件类型的批量合并和拆分问题/01"><span>01 | 拆分与合并：如何快速地批量处理内容相似的Excel？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/02.“输入”模块不同文件类型的批量合并和拆分问题/02"><span>02｜善用Python扩展库：如何批量合并多个文档？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/02.“输入”模块不同文件类型的批量合并和拆分问题/03"><span>03｜图片转文字：如何提高识别准确率？</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-worklife/python自动化办公实战课/03.春节特别放送/01"><span>春节特别放送1｜实体水果店转线上销售的数据统计问题</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/03.春节特别放送/02"><span>春节特别放送2｜用自顶至底的思路解决数据统计问题</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/03.春节特别放送/03"><span>春节特别放送3｜揭晓项目作业的答案</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能">04.“运算”模块扩展常用的统计、搜索和排序功能</a><ul><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/01"><span>04 |  函数与字典：如何实现多次替换</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/02"><span>05 | 图像处理库：如何实现长图拼接？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/03"><span>06 | jieba分词：如何基于感情色彩进行单词数量统计？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/04"><span>07｜快速读写文件：如何实现跨文件的字数统计？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/05"><span>08｜正则表达式：如何提高搜索内容的精确度？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/06"><span>09｜扩展搜索：如何快速找到想要的文件？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/07"><span>10｜按指定顺序给词语排序，提高查找效率</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/04.“运算”模块扩展常用的统计、搜索和排序功能/08"><span>11 ｜通过程序并行计算，避免CPU资源浪费</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/05.“控制”模块增强办公软件及周边软硬件的交互能力">05.“控制”模块增强办公软件及周边软硬件的交互能力</a><ul><li><a href="/blog-worklife/python自动化办公实战课/05.“控制”模块增强办公软件及周边软硬件的交互能力/01"><span>12｜文本处理函数：三招解决数据对齐问题</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/05.“控制”模块增强办公软件及周边软硬件的交互能力/02"><span>13｜Excel插件：如何扩展Excel的基本功能？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/05.“控制”模块增强办公软件及周边软硬件的交互能力/03"><span>14｜VBA脚本编程：如何扩展Excel，实现文件的批量打印？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/05.“控制”模块增强办公软件及周边软硬件的交互能力/04"><span>15｜PowerShell脚本：如何实现文件批量处理的自动化？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作">06.“存储”模块和文件相关的常用操作</a><ul><li><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/01"><span>16｜循环与文件目录管理：如何实现文件的批量重命名？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/02"><span>17｜不同操作系统下，如何通过网络同步文件？</span></a></li><li><a aria-current="page" class="active" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03"><span>18｜http库：如何批量下载在线内容，解放鼠标（上）？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/04"><span>19｜http库：如何批量下载在线内容，解放鼠标（下）？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/05"><span>20｜不同文件混在一起，怎么快速分类？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/06"><span>21｜SQLite文本数据库：如何进行数据管理（上）？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/07"><span>22｜SQLite文本数据库：如何进行数据管理（下）？</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果">07.“输出”模块智能化输出自己的工作成果</a><ul><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/01"><span>23｜怎么用数据透视表更直观地展示汇报成果？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/02"><span>24｜条形、饼状、柱状图最适合用在什么场景下？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/03"><span>25｜图表库：想要生成动态图表，用Echarts就够了</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/04"><span>26｜快速提取图片中的色块，模仿一张大师的照片</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/05"><span>27｜zipfile压缩库：如何给数据压缩&amp;加密备份？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/06"><span>28｜Celery库：让计算机定时执行任务，解放人力</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/07"><span>29｜网络和邮件库：定时收发邮件，减少手动操作</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/07.“输出”模块智能化输出自己的工作成果/08"><span>30｜怎么快速把任意文件格式转成PDF，并批量加水印？</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/08.结束语">08.结束语</a><ul><li><a href="/blog-worklife/python自动化办公实战课/08.结束语/01"><span>结课测试题｜这些Python自动化办公的知识你都掌握了吗？</span></a></li><li><a href="/blog-worklife/python自动化办公实战课/08.结束语/02"><span>结束语｜和我一起成为10X效率职场人</span></a></li></ul></li><li><a href="/blog-worklife/python自动化办公实战课/summary">python自动化办公实战课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="批量下载图片的准备工作" data-depth="2"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#批量下载图片的准备工作"><span>批量下载图片的准备工作</span></a></li><li title="访问HTTP服务端的资源" data-depth="3"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#访问http服务端的资源"><span>访问HTTP服务端的资源</span></a></li><li title="使用requests-html下载一张图片" data-depth="3"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#使用requests-html下载一张图片"><span>使用requests-html下载一张图片</span></a></li><li title="如何批量下载图片" data-depth="2"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#如何批量下载图片"><span>如何批量下载图片</span></a></li><li title="使用XPath，匹配多张图片下载地址" data-depth="3"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#使用xpath匹配多张图片下载地址"><span>使用XPath，匹配多张图片下载地址</span></a></li><li title="使用循环，下载多张图片" data-depth="3"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#使用循环下载多张图片"><span>使用循环，下载多张图片</span></a></li><li title="小结" data-depth="2"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="18http库如何批量下载在线内容解放鼠标上"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#18http库如何批量下载在线内容解放鼠标上"><span class="icon icon-link"></span></a>18｜http库：如何批量下载在线内容，解放鼠标（上）？</h1><p>你好，我是尹会生。</p><p>我在前段时间遇到了下载大量图片的需求。具体来说，是在我训练AI识别猫时，必须要在电脑中存储大量猫的图片。但搜索到的图片都在网页中，我就需要先把它们一个个手动下载下来，再保存，然后才能进行后续的工作。</p><p>而且，随着我对AI训练工作的日益增多，这类需求会越来越丰富，我不仅要下载猫的图片，还要下载大量其他各种动物的图片。相信类似这种批量下载网页中的图片的需求，你在工作中会经常遇到。而这类需求，刚好能够使用Python的“requests-html”库实现批量下载，提高我们的工作效率。</p><p>因此呢，这节课我就以搜索到的猫的图片为例，给你讲解一下，我是怎么来批量下载图片的。</p><h2 id="批量下载图片的准备工作"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#批量下载图片的准备工作"><span class="icon icon-link"></span></a>批量下载图片的准备工作</h2><p>我把实现图片自动化批量下载的过程，拆分成四段难度逐渐递增的代码。这四段代码分别实现的是以下四个功能：</p><ol><li>访问HTTP服务器，得到搜索结果的整个网页；</li><li>在访问服务器之后下载一张图片；</li><li>找到多张图片的相似地址；</li><li>提取相似地址，下载多张图片。</li></ol><p>前两个功能，是批量下载图片的准备工作和前提。掌握了这两个功能，那么批量下载图片实现起来就容易多了。所以接下来，我们先来学习这两项准备工作。</p><h3 id="访问http服务端的资源"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#访问http服务端的资源"><span class="icon icon-link"></span></a>访问HTTP服务端的资源</h3><p>我们从难度最低的一段代码开始，怎么通过访问HTTP服务器，从而得到猫的搜索结果的整个网页。</p><p>访问HTTP服务器，我需要使用Python的第三方库<strong>requests-html库</strong>来实现。虽然Python在标准库中也自带了访问服务器urllib库，但它的实现代码不够简洁，所以我一般数情况下会使用requests-html库替代它，来进行HTTP服务器的访问。</p><p>使用reqeusts-html库，你先需要通过**“pip”来安装**，再通过<strong>get()方法访问HTTP服务器</strong>。</p><p>安装requests-html库的方法，和我们<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/353826">上一讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>安装flask库是一样的。这里我强调一下，在Python中，绝大多数的第三方库，它们的名称和安装包的名称是相同的，所以除了特殊的安装方法外，像这种通用的安装方法，我就不会每次都重复贴出来了。reqeusts库的安装方法，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pip3 install requests-html</span></div></pre></div><p>在命令行执行后，requests-html库就安装成功了。接下来，我们就使用它的get()方法去请求HTTP服务器，而得到的返回数据，就是网页的代码。</p><p>相信你还记得在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/353826">上一讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我介绍了两种常见的HTTP服务端请求的方式，分别是“GET”和“POST”。requests-html库就是使用了同名函数实现的“GET”方式访问。</p><p>那么接下来，我将使用reqeusts库来访问一个<a target="_blank" rel="noopener noreferrer" href="http://www.upsplash.com/">无版权的图片网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，并得到网页的源代码。我把代码写出来，供你参考。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">from requests_html import HTMLSession</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # URL</span></div><div class="token-line"><span class="token plain">    name = &quot;猫&quot;</span></div><div class="token-line"><span class="token plain">    url = f&quot;https://unsplash.com/s/photos/{name}&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 启动</span></div><div class="token-line"><span class="token plain">    session = HTMLSession()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # GET请求</span></div><div class="token-line"><span class="token plain">    result = session.get(url)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 结果</span></div><div class="token-line"><span class="token plain">    print(result.status_code)</span></div><div class="token-line"><span class="token plain">    print(result.html.html)</span></div></pre></div><p>在这段代码中，我用requests-html代替浏览器来作为HTTP客户端，通过“session.get()”函数，向upsplash网站提供的HTTPS服务器发起“GET”请求。发送请求后，“result”变量会得到HTTP服务端响应的结果，即网页的源代码。</p><p>你肯定会有疑问，为什么我要用requests-html来代替浏览器呢？原因就在于，浏览器得到了网页内容后，如果你想再通过网页下载图片，还需要通过鼠标和网页的交互。这就会带来一个新的问题：交互式命令是不能进行图片的自动化下载的。也就是说，我们必须让交互操作变成非交互操作，才能进行批量下载图片。</p><p>总之呢，在这段代码中，我使用了requests-html代替浏览器实现了一次完整的网址的访问，这一过程为后续的自动化下载打下了坚实的基础。</p><p>而在这次网址的访问中，最核心的就是发起“GET”请求了。我把这次完整的“GET”请求拆分成了四个步骤。</p><p>其中前两个步骤是准备工作。准备工作是指在发送正式的数据之前，需要确定你需要向哪一个互联网当中的服务器发起请求，以及尝试和他建立连接，判断是否能够正常访问。</p><p>这就像你跟其他人打电话一样，你要确定你输入的电话号码是正确的，而且在拨打电话以后，还可以根据电话那个提示音，知道对方的电话是否处于可接通状态。</p><p>那后两步呢，就是在这个基础上和对方正式开始通话，但是他和打电话的区别是 HTTP协议会采用一问一答的形式，也就是发送一次请求会得到一次结果，不发请求也不会得到任何结果。接下来我们就来详细看一下这4个步骤。</p><p><strong>第一步，设置请求的URL。</strong></p><p>通过使用requests-html请求该网站，你会发现请求的大部分地址都是固定的，只有搜索的关键字会随着搜索的内容不同而发生变化。</p><p>所以我把搜索的关键字单独提取出来，放在一个字符串“name”中，当你需要更改搜索的关键字时，直接修改“name”变量就可以了。而其他在请求过程中没有发生变化的字符串，则放在url字符串中。与此同时，我还把url设置为“f-string”，方便我进行变量“name”的替换。</p><p>这一步是比较简单的，不过我在里面花了点小心思。仔细观察字符串，像字符串中只有某几个位置发生了变化，那么其余的部分就是<strong>重复的逻辑</strong>。针对这种重复的逻辑，可以被定义成变量来重复使用，减少重复工作。</p><p>还有我们以前接触过的，比如把文件目录和文件名拼接后，会形成一个很长的完整文件名。当文件名被多个函数重复使用时，你就不必每次都执行拼接，而是可以在拼接后被定义成变量来重复使用。</p><p>我补充这一点是想告诉你，你在写代码时也要多观察代码中哪些部分是重复的逻辑，这些重复的逻辑往往都可以使用变量来进行定义。一个小小的技巧，有时候就能给你的重复工作带来非常大的效率提升。</p><p><strong>第二步，启动一个会话。</strong></p><p>会话是HTTP协议中的一个概念。当你的客户端和服务端建立了连接时，我们就称一个会话建立成功了。它就像你和你的小伙伴使用微信进行视频，当对方接通视频的那一刻，就建立了一个新的会话。</p><p>在这段代码中，我使用了“HTMLSession”类初始化了一个叫做“session”的会话，用来后续向HTTP服务端继续发送请求。</p><p><strong>第三步，发送“GET”请求。</strong></p><p>建立会话之后，就要可以开始传输数据了。在这段代码中，我使用了get()函数把数据包装成标准的HTTP协议，然后向我在第一步定义的“URL”发起“GET”方式请求。</p><p><strong>第四步，得到返回结果。</strong></p><p>请求发送完成之后，“result“变量会自动得到服务器的结果，无论结果是成功还是失败，“result”变量都会得到返回的状态码以及数据。</p><p>所以在这一步，我们需要着重掌握怎么判断服务器返回的是成功还是失败的结果。我使用了“result.status_code”来得到返回的状态码。状态码是HTTP协议规定的标准，正确返回为200 ，其他返回你可以参考<a target="_blank" rel="noopener noreferrer" href="https://www.wiki-wiki.top/baike-HTTP%E7%8A%B6%E6%80%81%E7%A0%81?wprov=srpw1_0">维基百科<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>根据不同的状态码，你能判断网页返回的状态，并进行后续处理。比如我们经常使用状态码“200”确认网页是正确返回了内容，这意味着我得到“200”这个返回码之后，就可以继续处理网页数据了。</p><p>如果返回码是“4xx或5xx”，说明出现了请求过程的客户端或者服务端错误，HTTP客户端并没有得到网页的内容，这时候你就必须停止程序后续的逻辑，并向执行者提示错误信息。具体的判断方法就是我们的老朋友if语句了。</p><p>在这段代码中，我们得到了状态码200，那接下来我就使用“result.html.html”，得到了完整的网页源代码。</p><p>这四个步骤，就是使用“requests-html”库得到指定网页源代码的完整流程。接下来就要分析网站的行为，来下载单张图片。</p><h3 id="使用requests-html下载一张图片"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#使用requests-html下载一张图片"><span class="icon icon-link"></span></a>使用requests-html下载一张图片</h3><p>下载单张图片是图片批量下载的基础。为什么要这么说呢？因为我们可以通过观察一张图片的下载行为，把浏览器的下载操作转换成Python的代码，这样就可以循环批量下载图片了。而观察单张图片的下载行为，换句话说就是用Python来模拟浏览器。</p><p>具体思路是这样的：在使用Python按照浏览器的行为进行下载后，我们可以对服务端的HTML代码进行分析，从而得到多个图片在服务端存储的代码逻辑，之后就可以利用循环批量下载图片了。那接下来我就用例子带着你来学习一下。</p><p>使用浏览器下载一张图片的时候，当你把鼠标移动到下载按钮，你会发现它是在访问图片的URL后面增加了一串“download”字符。</p><p>我用一张图片的访问和下载给你举个例子，例如下载下面这张图片：</p><p><img src="/blog-worklife/static/httpsstatic001geekbangorgresourceimage25722579790ce800ef4fea833a8eb6475872.18a0d3ee.png" alt=""/></p><p>这张图片的<a target="_blank" rel="noopener noreferrer" href="https://unsplash.com/photos/NLzaiXOELFY">访问地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://unsplash.com/photos/NLzaiXOELFY/download">下载地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>我贴了出来，供你学习。</p><p>在你清楚浏览器是如何下载一张图片的之后，我们就可以使用“requests-html”下载单张图片了。下载单张图片的完整代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">from requests_html import HTMLSession</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # URL</span></div><div class="token-line"><span class="token plain">    url = &quot;https://unsplash.com/photos/NLzaiXOELFY/download&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 启动</span></div><div class="token-line"><span class="token plain">    session = HTMLSession()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # GET请求</span></div><div class="token-line"><span class="token plain">    result = session.get(url)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 结果</span></div><div class="token-line"><span class="token plain">    print(result.status_code)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 保存图片</span></div><div class="token-line"><span class="token plain">    with open(&quot;one.jpg&quot;, &quot;wb&quot;) as f:</span></div><div class="token-line"><span class="token plain">        f.write(result.content)</span></div></pre></div><p>这段代码中的保存文件功能是我想重点为你讲解的内容。在访问网页得到图片的下载地址的基础上，我增加了“with open” 语句，打开了一个文件，并以“wb”作为参数，实现文件的二进制写入。</p><p>由于图片是由“01010... ...”形式的二进制组成的，所以写入和下载都必须使用二进制方式实现。可以看到，在设置文件写入方式的时候，我增加了b参数，让文件以二进制方式写入文件，这样我们就能从服务器获得的图片内容的同时，也以二进制方式得到了返回结果的修改。</p><p>接着，我把“result.html”改成了“result.content”，使用二进制方式来获取图片内容。通过这样的方式，最终就把文件保存成“one.jpg”了。当你运行脚本后，在运行脚本的目录下就会产生一个“one.jpg”的图片。</p><p>这就是完整的使用“requests-html”下载单个图片的过程。</p><h2 id="如何批量下载图片"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#如何批量下载图片"><span class="icon icon-link"></span></a>如何批量下载图片</h2><p>请求网页和下载图片是实现批量下载的基础，这两部分已经使用Python自动完成了，接下来就是如何将它们组合起来。我来组合它们的思路是这样的：</p><p>首先，你要把它们当作两个独立的功能，找出两个功能的输入和输出是什么。</p><p>**请求网页的输入是一个即将要请求的URL地址，输出则是网页源代码。那下载图片的输入输出是什么呢？我们以下载单个图片为例，**下载图片的输入是图片的地址，执行下载图片的功能之后你会得到保存在硬盘上面的一张图片。因此，<strong>下载图片的输入是图片地址，输出是图片文件。</strong></p><p><strong>接下来，需要从前一个功能的输出找到后一个功能输入需要的数据。</strong></p><p>这里的前后是指执行顺序的前后，那么从请求网页得到的网页源代码中找到下载图片的地址是关联这两个功能最关键的技术点。而在编码的时候，我会将这两个功能编写为两个函数，函数的执行结果就是功能的输出，而函数的参数实现的就是功能的输入，通过前一个函数的输出和后一个函数的参数就能实现它们之间的功能连接了。</p><p><strong>最后是找规律。尽可能地找到多张图片之间的HTML代码的规律，从而实现批量下载。</strong></p><p>根据上面我提到的组合两个函数的思路，你不难发现，要想实现批量下载图片函数，必须先得到每个图片的下载地址，而下载地址会出现在请求网页的函数执行结果中。接下来我们就从请求网页函数的执行结果--网页的HTML代码入手，寻找图片的下载地址，并从这些下载地址中寻找规律，批量提取下载地址。</p><h3 id="使用xpath匹配多张图片下载地址"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#使用xpath匹配多张图片下载地址"><span class="icon icon-link"></span></a>使用XPath，匹配多张图片下载地址</h3><p>想要找到图片的下载地址以及它们的规律，最直观的办法就是通过浏览器的调试界面，观察它们的代码。</p><p>你可以使用浏览器访问 “<a target="_blank" rel="noopener noreferrer" href="https://unsplash.com/s/photos/%E7%8C%AB">https://unsplash.com/s/photos/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>猫” URL后，再通过浏览器的调试功能，打开调试界面。我以最流行的Chrome浏览器为例，它的调试窗口打开快捷键是“F12”，打开调试界面后的截图如下，供你参考：</p><p><img src="/blog-worklife/static/httpsstatic001geekbangorgresourceimage315331757b9f98904fee2acae68ba3c58f53.d3dee853.png" alt=""/></p><p>截图左侧就是调试页面，截图的右侧是网页的内容，你可以通过截图左上角的“选择元素按钮”<br/><img src="/blog-worklife/static/httpsuploadershimoimf0FFEmWfYRSiY0t0g.bbc40a30.png" alt=""/><br/>点击图片，左侧的调试界面会自动定位到图片对应的HTML代码。而你向上查找，会发现图片下方的“&lt;a&gt;”标签的“href”属性，就记录了图片ID和下载地址。</p><p>这里我有必要为你介绍一下HTML的标。你在网页上看到的每个元素，都是由不同类型的标签组成的。</p><p>例如图片使用的是“&lt;img&gt;”标签，超链接使用的是“&lt;a&gt;”标签。每个标签还使用了相应的属性，来记录该标签的具体信息。比如把一个人作为标签，他可以有性别、身高、年龄等属性。“&lt;a&gt;”标签的“href”属性就记录了超链接的地址，我们可以使用超链接地址来完成图片的批量下载。</p><p>那用什么方法能一次性找到链接呢？聪明的你一定想到了我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/346724">第8讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>学过的正则表达式。正则表达式是分析网页的常用工具之一，不过还有一种比正则表达式更方便的**网页内容搜索工具，那就是XPath。**我们可以使用XPath来找到超链接。</p><p>如果你对使用正则表达式分析网页也感兴趣，你可以把它跟XPath进行对比，选择一个自己顺手的工具，这也是提升工作效率的技巧之一。</p><p>我先把XPath查找的方法和结果写在下面的代码中， 然后再为你分析XPath的用法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">print(result.html.xpath(&#x27;//figure[@itemprop=&quot;image&quot;]//a[@rel=&quot;nofollow&quot;]/@href&#x27;))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # [&#x27;https://unsplash.com/photos/NLzaiXOELFY/download?force=true&#x27;, </span></div><div class="token-line"><span class="token plain">    #  &#x27;https://unsplash.com/photos/3JyEfhb8Zgo/download?force=true&#x27;, </span></div><div class="token-line"><span class="token plain">    #  &#x27;https://unsplash.com/photos/4Y6UYds0cIo/download?force=true&#x27;, </span></div><div class="token-line"><span class="token plain">    #  ... ...</span></div><div class="token-line"><span class="token plain">    # ]</span></div></pre></div><p>在这段代码中，使用result.html.xpath()函数就能实现XPath查找网页的功能。XPath查找网页时也有它自己的语法，我在这里使用了<strong>路径、标签、属性</strong>三个功能。我来依次带你学习一下它们的用途。</p><p>首先是路径，HTML的整体结构是由头部标签“”和主体标签“”组成的，而网页的内容是在主体标签下逐层编写的，它的结构如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;head&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/head&gt;</span></div><div class="token-line"><span class="token plain">    &lt;body&gt;</span></div><div class="token-line"><span class="token plain">        &lt;div num=1&gt;</span></div><div class="token-line"><span class="token plain">            &lt;figure itemprop=&quot;image&quot;&gt;</span></div><div class="token-line"><span class="token plain">               ... ...</span></div><div class="token-line"><span class="token plain">               &lt;div num=2&gt; </span></div><div class="token-line"><span class="token plain">                  ... ...  </span></div><div class="token-line"><span class="token plain">                  &lt;a rel=&quot;nofollow&quot; href=http://...&gt;</span></div><div class="token-line"><span class="token plain">                  ... ...</span></div><div class="token-line"><span class="token plain">               &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/figure&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/body&gt;</span></div></pre></div><p>以上面的结构为例，如果网页内容简单，你可以像使用windows的路径一样，使用“/body/div/fugure”方式搜索到“figure”标签。但是当匹配路径超过3个时，把路径逐个写在XPath搜索表达式中不太容易，那我们就一般使用模糊路径来搜索“//”。比如要搜索一个</p><div>标签，就可以使用“//<div>”的方式。<p></p><p>接着是<strong>标签。</strong>我在xpath()函数中，使用了figure和a标签。“finger”是自定义标签，“a”是超链接的标签，它们和路径组成了下面这行代码的形式：</p><pre><code>xpath(&#x27;//figure//a&#x27;)<!-- -->
</code></pre><p>这一条XPath的功能是从任意位置开始搜索“figure”标签，并在它下面任意一级目录中找到“a”标签。这显然不符合我们只提取图片下载地址的要求，因此我们要通过属性增加这两个标签的限定条件。</p><p>接下来，我为“figure”标签增加了限定条件，要求它的<strong>属性和属性的值，必须和xpath()函数搜索的属性和值完全相同。</strong></p><p>xpath()的匹配规则中要求“figure”标签必须包含“itemprop”属性，且这一属性的值是“image”，为“a”标签设置查找的属性必须为“rel”， 且它的值必须是“nofollow”。这样xpath()中的两个标签就变成了如下的写法：</p><pre><code>xpath(&#x27;//figure[@itemprop=&quot;image&quot;]//a[@rel=&quot;nofollow&quot;]&#x27;)<!-- -->
</code><p><code></code></p></pre><p>通过增加属性，限定了搜索的标签，可以得到需要下载的“&lt;a&gt;”标签，“&lt;a&gt;”标签的规范写法要求链接地址写@href属性，链接的内容要写在它的值中，因此我们再为xpath()提取的“&lt;a&gt;”标签增加“@href”属性，即可以实现提取只包含图片地址的列表。我把完整的xpath()函数写在下方。</p><pre><code>xpath(&#x27;//figure[@itemprop=&quot;image&quot;]//a[@rel=&quot;nofollow&quot;]/@href&#x27;)<!-- -->
</code></pre><p>这就是利用xpath()的<strong>路径、标签、属性搜索超链接的完整实现思路。</strong>我建议你打开网页调试器，通过“选择元素按钮”点击网页内容，对照这段网页源代码和xpath()语法来学习，这样更有利于你快速掌握怎么使用Xpath匹配多张图片的下载地址。</p><h3 id="使用循环下载多张图片"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#使用循环下载多张图片"><span class="icon icon-link"></span></a>使用循环，下载多张图片</h3><p>在你得到了多张图片的下载地址列表后，接下来我们只需要把下载单个图片的代码和列表功能进行组合，这样就能实现图片的批量下载了。我先把核心代码写出来，供你参考，然后再讲解思路。</p><pre><code>down_list = result.html.xpath(&#x27;//figure[@itemprop=&quot;image&quot;]//a[@rel=&quot;nofollow&quot;]/@href&#x27;)<p></p>
<p>def down_one_pic(url):<!-- -->
<!-- -->result = session.get(url)<!-- -->
<!-- -->filename = get_picID_from_url(url)<!-- -->
<!-- -->with open(filename, &quot;wb&quot;) as f:<!-- -->
<!-- -->f.write(result.content)</p>
<p>for one_url in down_list:<!-- -->
<!-- -->down_one_pic(one_url)</p>
</code><p><code></code></p></pre><p>实现文件批量下载的主要思路，就是把下载地址列表使用for循环逐个进行处理。通过循环取得了每个下载地址的变量“one_url”之后，再把“one_url”作为下载函数的参数，并通过URL提取文件名后，把文件下载并保存。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>以上就是我们今天的全部内容了，我来为你总结一下。在本讲中主要以批量下载图片为例，为你讲解了Python中实现HTTP客户端常用的“requests-html”库、进行网页搜索的XPath搜索工具。</p><p>通过这两个库的配合使用，你可以利用Python代替浏览器，实现图片、文字、视频等资源的批量下载，在你熟练掌握“XPath“之后，再遇到需要批量下载的工作，你就可以利用Python解放你的鼠标，实现网页内容的批量自动化下载了。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-worklife/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/353153">第16讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们实现了文件的批量改名功能，你能否将批量改名功能也封装成一个函数，结合今天的批量下载，实现下载之后的文件自动改成你需要的文件名呢？</p><p>欢迎把你的思考和想法分享在留言区，我们一起交流、讨论。也欢迎你把我们的课程分享给你的朋友、同事，一起做职场上的效率人。我们下节课再见！</p></div></div></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/python自动化办公实战课/06.“存储”模块和文件相关的常用操作/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:28:22</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-worklife/umi.4ad44284.js"></script>
  </body>
</html>
